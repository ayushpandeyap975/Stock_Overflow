{% extends "base.html" %}
{% load static %}

{% block content %}
<link href="{% static 'designs/stockeye.css' %}" rel="stylesheet">
<br>
<div class="card" style="max-width: 75%; transform: translateX(18%)">
    <div class="card-body" >
        
        <div class="chat-container">
            <!-- Chat Header -->
            <div class="chat-header">
                <div class="header-left">
                    <div class="avatar">
                        <img src="{% static 'images/chatbot.png' %}" alt="Stock Eye Avatar" width="50" height="50">
                    </div>
                    <div>
                        <div class="header-title">Stock Eye</div>
                        <div class="header-subtitle">Your own financial helper</div>
                    </div>
                </div>
            </div>

            <!-- Chat Messages -->
            <div class="chat-messages" id="chatMessages"  style="background-image: url('{% static 'images\so-bg2.jpg' %}'); background-repeat: no-repeat;  background-size: cover;">
                <!-- Default bot greeting message -->
                <div class="message bot-message">
                    <div class="avatar">
                        <img src="{% static 'images/chatbot.png' %}" alt="Chatbot">
                    </div>
                    <div class="message-content">Hello! StockEye here. How can I help you?</div>
                </div>
            </div>

            <!-- Input Area -->
            <div id="speech-controls" style="display: flex; align-items: center; justify-content: flex-end; gap: 18px; margin-bottom: 8px; background: #1a2634; border-radius: 8px; padding: 8px 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
                <label style="display: flex; align-items: center; color: #fff; font-size: 1rem; gap: 6px; cursor: pointer;">
                    <input type="checkbox" id="speakToggle" checked style="accent-color: #00bcd4; width: 18px; height: 18px; margin-right: 4px;">
                    <span style="user-select: none;">üîä Speak Bot Response</span>
                </label>
                <label style="display: flex; align-items: center; color: #fff; font-size: 1rem; gap: 6px;">
                    <span style="user-select: none;">üåê Language:</span>
                    <select id="langSelect" style="background: #22304a; color: #fff; border: none; border-radius: 4px; padding: 2px 8px; font-size: 1rem;">
                        <option value="en-IN" id="eni">English (India)</option>
                        <option value="hi-IN">Hindi (‡§π‡§ø‡§®‡•ç‡§¶‡•Ä)</option>
                        <option value="en-US">English (US)</option>
                        <option value="ta-IN">Tamil (‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç)</option>
                        <option value="te-IN">Telugu (‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å)</option>
                        <option value="bn-IN">Bengali (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ)</option>
                        <option value="gu-IN">Gujarati (‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä)</option>
                        <option value="kn-IN">Kannada (‡≤ï‡≤®‡≥ç‡≤®‡≤°)</option>
                        <option value="ml-IN">Malayalam (‡¥Æ‡¥≤‡¥Ø‡¥æ‡¥≥‡¥Ç)</option>
                        <option value="mr-IN">Marathi (‡§Æ‡§∞‡§æ‡§†‡•Ä)</option>
                        <option value="pa-IN">Punjabi (‡®™‡©∞‡®ú‡®æ‡®¨‡©Ä)</option>
                        <option value="ur-IN">Urdu (ÿßÿ±ÿØŸà)</option>
                    </select>
                </label>
            </div>
            <div class="chat-input">
                {% csrf_token %}
                <input type="text" class="message-input" placeholder="Type a message..." id="messageInput">
                <button class="send-button" id="sendButton">SEND</button>
                <button id="mic">üé§</button>
            </div>
        </div>
    </div>
</div>

{% comment %} <!-- JavaScript for Chat Interaction -->
<script>
    document.getElementById("sendButton").addEventListener("click", function () {
        let inputField = document.getElementById("messageInput");
        let messageText = inputField.value.trim();
    
        if (messageText !== "") {
            addMessage(messageText, "user"); // Show user message
            inputField.value = "";
    
            // Perform AJAX request to backend API
            $.ajax({
                type: "POST",
                url: "http://127.0.0.1:8000/market/chat_bot/", // Update to your Django API endpoint
                data: {
                    message: messageText,
                    csrfmiddlewaretoken: "{{ csrf_token }}" // Include CSRF token for Django security
                },
                success: function (response) {
                    if (response && response.response) {
                        addMessage(response.response, "bot"); // Display bot response
                    } else {
                        addMessage("Sorry, I couldn't understand that.", "bot");
                    }
                },
                error: function () {
                    addMessage("Oops! Something went wrong. Please try again later.", "bot");
                }
            });
        }
    });
    
    function addMessage(text, sender) {
        let chatBox = document.getElementById("chatMessages");
        let messageDiv = document.createElement("div");
        messageDiv.classList.add("message");
    
        if (sender === "user") {
            messageDiv.classList.add("user-message");
        } else {
            messageDiv.classList.add("bot-message");
            let avatarDiv = document.createElement("div");
            avatarDiv.classList.add("avatar");
            let img = document.createElement("img");
            img.src = "{% static 'images/chatbot.png' %}";
            img.alt = "Chatbot";
            avatarDiv.appendChild(img);
            messageDiv.appendChild(avatarDiv);
        }
    
        let textDiv = document.createElement("div");
        textDiv.classList.add("message-content");
        textDiv.textContent = text;
        messageDiv.appendChild(textDiv);
        chatBox.appendChild(messageDiv);
    
        // Scroll to the bottom
        chatBox.scrollTop = chatBox.scrollHeight;
    }
</script> {% endcomment %}


<script>
    const micBtn = document.getElementById('mic');
    const synth = window.speechSynthesis;
    
    let recognition;
    let isListening = false;
    let allVoices = [];
    
    // üéôÔ∏è Load all available voices once browser is ready
    window.speechSynthesis.onvoiceschanged = () => {
        allVoices = speechSynthesis.getVoices();
        // Debug: Log all available voices
        console.log('Available voices:', allVoices.length);
        allVoices.forEach((voice, index) => {
            console.log(`${index + 1}. ${voice.name} (${voice.lang}) - ${voice.gender || 'unknown gender'}`);
        });
    };
    
    if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
        recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        recognition.lang = 'en-IN';
        recognition.interimResults = false;
        recognition.continuous = false;
    } else {
        recognition = null;
        micBtn.disabled = true;
        micBtn.title = "Speech recognition not supported in this browser.";
    }
    
    document.addEventListener("DOMContentLoaded", function () {
        const inputField = document.getElementById("messageInput");
        const sendButton = document.getElementById("sendButton");
        const chatBox = document.getElementById("chatMessages");
    
        micBtn.addEventListener('click', () => {
            if (!recognition) {
                alert("Speech recognition is not supported in this browser.");
                return;
            }
            if (!isListening) {
                recognition.start();
                micBtn.classList.add("listening");
            } else {
                recognition.stop();
                micBtn.classList.remove("listening");
            }
        });
    
        if (recognition) {
            recognition.onresult = function (event) {
                const transcript = event.results[0][0].transcript;
                inputField.value = transcript;
            };
    
            recognition.onstart = () => isListening = true;
            recognition.onend = () => {
                isListening = false;
                micBtn.classList.remove("listening");
            };
    
            recognition.onerror = function (event) {
                isListening = false;
                micBtn.classList.remove("listening");
                const errMsgs = {
                    "no-speech": "No speech detected, please try again!",
                    "audio-capture": "No microphone found.",
                    "not-allowed": "Mic access denied."
                };
                inputField.placeholder = errMsgs[event.error] || `Speech recognition error: ${event.error}`;
                setTimeout(() => inputField.placeholder = "Type a message...", 2500);
            };
        }
    
        sendButton.addEventListener("click", sendMessage);
        inputField.addEventListener("keypress", function (event) {
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        });
    
        function sendMessage() {
            let messageText = inputField.value.trim();
            if (messageText === "") return;
    
            addMessage(messageText, "user");
            inputField.value = "";
    
            let typingMessage = addMessage("AI is generating a response...", "bot", true);
    
            $.ajax({
                type: "POST",
                url: "http://127.0.0.1:8000/market/chat_bot/",
                data: {
                    message: messageText,
                    csrfmiddlewaretoken: "{{ csrf_token }}"
                },
                success: function (response) {
                    removeTyping(typingMessage);
                    if (response && response.response) {
                        animateTyping(response.response, "bot");
                        const speakToggle = document.getElementById('speakToggle');
                        const langSelect = document.getElementById('langSelect');
                        if (speakToggle && speakToggle.checked) {
                            speak(response.response, langSelect ? langSelect.value : 'en-IN');
                        }
                    } else {
                        addMessage("Sorry, I couldn't understand that.", "bot");
                    }
                },
                error: function () {
                    removeTyping(typingMessage);
                    addMessage("Oops! Something went wrong. Please try again later.", "bot");
                }
            });
        }
    
        function addMessage(text, sender, isTyping = false) {
            let messageDiv = document.createElement("div");
            messageDiv.classList.add("message", sender === "user" ? "user-message" : "bot-message");
    
            if (sender === "bot") {
                let avatarDiv = document.createElement("div");
                avatarDiv.classList.add("avatar");
                let img = document.createElement("img");
                img.src = "{% static 'images/chatbot.png' %}";
                img.alt = "Chatbot";
                avatarDiv.appendChild(img);
                messageDiv.appendChild(avatarDiv);
            }
    
            let textDiv = document.createElement("div");
            textDiv.classList.add("message-content");
            textDiv.textContent = text;
            messageDiv.appendChild(textDiv);
            chatBox.appendChild(messageDiv);
    
            messageDiv.style.opacity = "0";
            messageDiv.style.transform = "translateY(10px)";
            setTimeout(() => {
                messageDiv.style.opacity = "1";
                messageDiv.style.transform = "translateY(0)";
            }, 100);
    
            chatBox.scrollTop = chatBox.scrollHeight;
    
            return isTyping ? messageDiv : textDiv;
        }
    
        function removeTyping(typingMessage) {
            if (typingMessage) typingMessage.remove();
        }
    
        function animateTyping(text, sender) {
            let textDiv = addMessage("", sender);
            let words = text.split(" ");
            let index = 0;
    
            function typeWord() {
                if (index < words.length) {
                    textDiv.textContent += words[index] + " ";
                    index++;
                    chatBox.scrollTop = chatBox.scrollHeight;
                    setTimeout(typeWord, 100);
                }
            }
    
            typeWord();
        }
    
        // üåç Translation function using LibreTranslate
        async function translateText(text, targetLang) {
            try {
                const response = await fetch('https://libretranslate.com/translate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        q: text,
                        source: 'en',
                        target: targetLang.split('-')[0], // e.g., "hi" from "hi-IN"
                        format: 'text'
                    })
                });
    
                if (!response.ok) throw new Error('Translation failed');
    
                const data = await response.json();
                return data.translatedText;
            } catch (error) {
                console.error('Translation error:', error);
                return null;
            }
        }
    
        // üîä Speak the bot response in selected language
        async function speak(originalText, selectedLangCode = 'en-IN') {
            let textToSpeak = originalText;
            let langCode = selectedLangCode;
    
            if (!langCode.startsWith('en')) {
                const translated = await translateText(originalText, langCode);
                if (translated) {
                    textToSpeak = translated;
                } else {
                    console.warn("Fallback to English: translation failed.");
                    langCode = 'en-IN';
                }
            }
    
            // Try multiple TTS methods for better multilingual support
            await speakWithMultipleMethods(textToSpeak, langCode);
        }

        // Enhanced multilingual TTS with multiple fallback methods
        async function speakWithMultipleMethods(text, langCode) {
            const lang = langCode.split('-')[0]; // Get language code (e.g., 'hi' from 'hi-IN')
            
            // Method 1: Try Google Translate TTS (works for most languages including Hindi)
            try {
                await speakWithGoogleTTS(text, lang);
                return;
            } catch (error) {
                console.log('Google TTS failed, trying browser TTS...');
            }
            
            // Method 2: Try browser's speech synthesis with better voice selection
            try {
                await speakWithBrowserTTS(text, langCode);
                return;
            } catch (error) {
                console.log('Browser TTS failed, trying fallback...');
            }
            
            // Method 3: Fallback to English with Indian accent
            console.log('All TTS methods failed, using English fallback');
            await speakWithBrowserTTS(text, 'en-IN');
        }

        // Google Translate TTS method (works for Hindi, Tamil, etc.)
        async function speakWithGoogleTTS(text, lang) {
            return new Promise((resolve, reject) => {
                const audio = new Audio();
                const encodedText = encodeURIComponent(text);
                const url = `https://translate.google.com/translate_tts?ie=UTF-8&q=${encodedText}&tl=${lang}&client=tw-ob`;
                
                audio.src = url;
                audio.onloadstart = () => {
                    console.log(`Playing Google TTS for ${lang}: ${text.substring(0, 50)}...`);
                };
                audio.onended = () => resolve();
                audio.onerror = (error) => {
                    console.error('Google TTS error:', error);
                    reject(error);
                };
                
                synth.cancel(); // Stop any current speech
                audio.play().catch(reject);
            });
        }

        // Enhanced browser TTS with better voice selection
        async function speakWithBrowserTTS(text, langCode) {
            return new Promise((resolve, reject) => {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = langCode;
                
                // Enhanced voice selection
                let voices = allVoices;
                let selectedVoice = null;
                
                // Try exact language match
                selectedVoice = voices.find(v => v.lang === langCode);
                
                // Try language family match
                if (!selectedVoice) {
                    const langFamily = langCode.split('-')[0];
                    selectedVoice = voices.find(v => v.lang && v.lang.startsWith(langFamily));
                }
                
                // Try any Indian English voice for Indian languages
                if (!selectedVoice && langCode.includes('-IN')) {
                    selectedVoice = voices.find(v => v.lang && v.lang.includes('en-IN'));
                }
                
                // Prefer female voices
                if (selectedVoice) {
                    const femaleVoice = voices.find(v => 
                        v.lang === selectedVoice.lang && 
                        (v.name.toLowerCase().includes('female') || v.gender === 'female')
                    );
                    if (femaleVoice) selectedVoice = femaleVoice;
                }
                
                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                    console.log(`Using browser voice: ${selectedVoice.name} for ${langCode}`);
                } else {
                    console.log(`No specific voice found for ${langCode}, using default`);
                }
                
                utterance.onend = () => resolve();
                utterance.onerror = (error) => reject(error);
                
                synth.cancel();
                synth.speak(utterance);
            });
        }
    });
</script>
    

{% endblock %}
